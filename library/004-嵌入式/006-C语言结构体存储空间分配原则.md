# C语言结构体存储空间分配的原则
>维护人员：**80后老男孩**  
>创建时间：2021-03-14  

> **修改日志：**

> - 【2020-03-14】  新增

> 本文已发表于csdn博客：[C语言结构体存储空间分配的原则](https://blog.csdn.net/weixin_41034400/article/details/114801068)

我们在嵌入式编程中经常用到结构体，结构体内成员变量的声明顺序不同，会带来结构体整体存储空间大小的不同，这是因为在C语言里，结构体里元素存储要对齐，这个“对齐”里面包含了很多微妙的东西。

**结构体内存存储空间分配的原则**：
编译器按照成员列表顺序一个接一个地给每个成员分配内存。只有当存储成员时需要满足正确的边界对齐要求时，成员之间才可能出现用于填充的额外内存空间。

**而且还有3点原则**：

1. 结构体变量的首地址要能够被其最宽基本类型元素的大小所整除。
2. 结构体的每个元素相对于结构体首地址的偏移量（offset）都是元素大小的整数倍，如有需要编译器会在元素之间加上填充字节（internal adding）。
3. 结构体的总大小为结构体最宽基本类型元素大小的整数倍，如有需要编译器会在最末一个元素之后加上填充字节（trailing padding）。

下面来看几个例子(以32位arm或单片机系统为例)：  
sizeof操作符能够得出一个结构的整体长度，包括因边界对齐而跳过的那些字节。所以一般都用sizeof来计算其所占存储空间，比如sizeof(t1)、sizeof(int)、sizeof(char)就可以计算结构体t1、int型、char型变量的存储空间大小。

```c
struct t1
{
	int a;
	char b;
	char c;
};
```
首先创建的是int类型的a为4字节，但是其后一个b只占1个字节，所以不要和char b对齐。因为其后一个c只占1个字节，所以也不用对齐。所以结构体t1一共占:4+1+1=6个字节，但是根据要求3，结构体的总大小为结构体最宽基本类型元素大小的整数倍。而在这个例子中，最宽的元素为int a，为4字节。所以最后结构体t1的总大小必须为4的倍数，因此最终的字节数为8。所以，这里编译器自动充填了2字节的充填字节。

下面让我们将例1中元素的顺序调一下位置看看:
```c
struct t2
{
	char b;
	int a;
	char c;
};
```
计算后可以得到t2总字节数为12。是不是很疑惑，为什么就是位置换了一下结果会有所不同呢？这就是前面定义中所说的顺序的问题。来分析一下，首先创建的是 char b为1字节，然后是 int a为4字节，要对齐，所以应该在b后添加3个字节创建 int a，因为最后的cahr c只占1字节，所以不用充填，所以总字节数为:4+4+1=9,还是因为要求3，应该为4的倍数，所以总字节为12(3个充填字节)。

那么加上数组呢？
```c
struct t3
{
	int a;
	char b[9];
	char c;
};
```
a占4个字节，b和c分别占9个字节和1个字节，加起来10个字节，但是因为要求3，这里最宽的元素为int，所以要为4的倍数，所以总共需要16个字节。

再掉一下位置
```c
struct t4
{
	char b[9];
	int a;
	char c;
};
```
b占9字节，a占4字节，为了对齐，这时候应该是12(9+3，因为char 比int少3字节，所以为了对齐要加上那3字节)+4个字节，后面又来一个c 也是char，为了对齐加4(1+3)，所以总共是20个字节。  
而t3因为后面两个元素类型一致，所以可以先和在一起分配，然后对齐。
所以可以知道，要不要对齐是看基本元素类型的，比如虽然char b[9]比int a占的字节要多，但是因为基本元素类型不一样，所以还是要对齐。